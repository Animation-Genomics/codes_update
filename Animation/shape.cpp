#include "shape.hpp"
#include "opengl.hpp"
#include <fstream>
using namespace std;

// reads an signed distance field grid from the format generated by SDFGen
// (https://github.com/christopherbatty/SDFGen)
void readSdf(Grid3<double> &grid, string sdffile) {
    fstream sdfstream(sdffile.c_str(), ios::in);
    int m, n, o;
    sdfstream >> m >> n >> o;
    Vector3d x0;
    sdfstream >> x0(0) >> x0(1) >> x0(2);
    double dx;
    sdfstream >> dx;
    grid = Grid3<double>(m, n, o, x0, dx);
    for (int i = 0; i < m*n*o; i++)
        sdfstream >> grid.values[i];
}

MeshShape::MeshShape(Vector3d x, Quaterniond q, double scale,
                     string meshfile, string sdffile):
    x(x), q(q), scale(scale) {
    mesh.readObj(meshfile);
    readSdf(sdf, sdffile);
}

void MeshShape::draw() {
    glPushMatrix();
    glTranslatef(x(0), x(1), x(2));
    glMultMatrixd(Affine3d(q).data());
    glScalef(scale, scale, scale);
    mesh.draw();
    glPopMatrix();
}

double MeshShape::distance(Vector3d x1) {
    // convert world-space position x1 to body-space position xBody
    Vector3d xBody = q.inverse()*(x1 - x)/scale;
    return sdf.interpolate(xBody)*scale;
}

Vector3d MeshShape::normal(Vector3d x1) {
    // convert world-space position x1 to body-space position xBody
    Vector3d xBody = q.inverse()*(x1 - x)/scale;
    return q*sdf.gradient(xBody).normalized();
}
